<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>LIPL Tutorial -- LIPL</title>
    <link href="style.css" rel="stylesheet" type="text/css" media="screen"/>
    <link href="print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<div id="wrap">
<div class="document" id="lipl-tutorial">
<h1 class="title">LIPL Tutorial</h1>
<h2 class="subtitle" id="stack-based-postfix-calculator">Stack Based Postfix Calculator</h2>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#about" id="id1">1&nbsp;&nbsp;&nbsp;About</a></li>
<li><a class="reference internal" href="#note" id="id2">2&nbsp;&nbsp;&nbsp;Note</a></li>
<li><a class="reference internal" href="#helper-functions" id="id3">3&nbsp;&nbsp;&nbsp;Helper Functions</a></li>
<li><a class="reference internal" href="#evaluator" id="id4">4&nbsp;&nbsp;&nbsp;Evaluator</a></li>
<li><a class="reference internal" href="#repl" id="id5">5&nbsp;&nbsp;&nbsp;REPL</a></li>
<li><a class="reference internal" href="#run" id="id6">6&nbsp;&nbsp;&nbsp;Run</a></li>
</ul>
</div>
<div class="section" id="about">
<h1><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;About</a></h1>
<p>Welcome to LIPL : a Little Idiotic Programming Language.
LIPL is a tiny functional language.
LIPL expressions are parenthesized prefix expressions.
So, LIPL looks similar to LISP language.</p>
<p>In this tutorial, a stack based postfix calculator is implemented.</p>
</div>
<div class="section" id="note">
<h1><a class="toc-backref" href="#id2">2&nbsp;&nbsp;&nbsp;Note</a></h1>
<p><tt class="docutils literal">LIPL&gt;</tt> is LIPL prompt.</p>
<pre class="literal-block">
LIPL&gt; &quot;hello&quot;
type: [Char]
&quot;hello&quot;
</pre>
<p>means to start the LIPL interpreter, type &quot;hello&quot; in the LIPL
prompt, and to press enter key.
Then it should print type of &quot;hello&quot; (list of Char) and value of &quot;hello&quot;
(&quot;hello&quot; itself).</p>
<p>All functions that are used here without defining them first
are from <tt class="docutils literal">core.lipl</tt> (standard library).
Or, they are built-in function in LIPL.</p>
</div>
<div class="section" id="helper-functions">
<h1><a class="toc-backref" href="#id3">3&nbsp;&nbsp;&nbsp;Helper Functions</a></h1>
<p>Open a text editor and save it as <tt class="docutils literal">calc.lipl</tt>.
Type this:</p>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">parse</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">words</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>

</div>
<p>This defines a function called parse that just calls function words.
In detail:</p>
<pre class="literal-block">
(def parse (x) (words x))
  |    |    |       +----- applies words function on x
  |    |    +------------- parameter this function takes
  |    +------------------ name of this function
  +----------------------- def is LIPL keyword
</pre>
<p><tt class="docutils literal">(words x)</tt> will split x on whitespaces:</p>
<pre class="literal-block">
LIPL&gt; (words &quot;I\t like\n  postfix so much.&quot;)
type: [[Char]]
[&quot;I&quot;, &quot;like&quot;, &quot;postfix&quot;, &quot;so&quot;, &quot;much.&quot;]
</pre>
<p>Type this in <tt class="docutils literal">calc.lipl</tt>:</p>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">printStack</span> <span class="p">()</span>
    <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">((</span><span class="nf">compose</span> <span class="nv">println</span> <span class="nv">show</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>
</pre></div>

</div>
<p>printStack does not take explicit argument.
However, function map is given only 1 parameter
when it takes 2 arguments:</p>
<pre class="literal-block">
(map (lambda (x) ((compose println show) x)))
     \--- first parameter -----------------/
          map needs 1 more parameter.
</pre>
<p>map takes a function and a list and applies the function
on each element in the list:</p>
<pre class="literal-block">
(map f [a,b,c])
==&gt; [(f a), (f b), (f c)]
</pre>
<p>And, <tt class="docutils literal">(lambda (x) ((compose println show) x))</tt>
is a function that takes 1 argument and prints it to the console:</p>
<pre class="literal-block">
(lambda (x) ((compose println show) x))
   |     |             +---------------- same as (println (show x))
   |     +------------------------------ the only parameter
   +------------------------------------ keyword
</pre>
<p>lambda keyword is used to create a nameless function.
Above nameless function takes a parameter and applies
a function <tt class="docutils literal">(compose println show)</tt> to it.
<tt class="docutils literal">((compose println show) x)</tt> is same as <tt class="docutils literal">(println (show x))</tt>.
<tt class="docutils literal">(show x)</tt> converts x to string representation and println
prints a string to the console.</p>
<p>So, printStack takes a list and prints each element to the console.</p>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">swapOp</span> <span class="p">(</span><span class="nf">st</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">st</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">println</span> <span class="s">&quot;not enough elements to swap&quot;</span><span class="p">)</span> <span class="nv">st</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="err">{</span><span class="nv">a</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">head</span> <span class="nv">st</span><span class="p">)</span><span class="o">,</span> <span class="nv">tl</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">tail</span> <span class="nv">st</span><span class="p">)</span>
            <span class="o">,</span> <span class="nv">b</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">head</span> <span class="nv">tl</span><span class="p">)</span><span class="o">,</span> <span class="nv">st</span><span class="o">&#39;</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">tail</span> <span class="nv">tl</span><span class="p">)</span><span class="err">}</span>
            <span class="p">(</span><span class="nb">cons </span><span class="nv">b</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="nv">st</span><span class="o">&#39;</span><span class="p">)))))</span>
</pre></div>

</div>
<p>swapOp takes 2 elements from a list (st)
using head and tail.
Before it takes 2 elements, it checks if the list
has at least 2 elements by checking its length with length function:</p>
<pre class="literal-block">
(&lt; (length st) 2)
 |     |       +--- 2
 |     +----------- length of st
 +----------------- is it less than?
</pre>
<p>When the list st has length less than 2, then
&quot;not enough elements to swap&quot; is printed and the list returned:</p>
<pre class="literal-block">
(seq (println &quot;...&quot;) st)
  |         |         +-- and st
  |         +------------ println
  +---------------------- sequentially evaluate
</pre>
<p>seq function takes 2 parameters and evaluates the first prameter.
Then it evaluates the 2nd parameter and returns the result.</p>
<p>head gives first element from a list.
tail gives a list excluding the first element:</p>
<pre class="literal-block">
LIPL&gt; (head &quot;abc&quot;)
type: Char
'a'
LIPL&gt; (tail &quot;abc&quot;)
type: [Char]
&quot;bc&quot;
</pre>
<p>Since strings are list of characters, head and tail can be applied
to strings, too.</p>
<pre class="literal-block">
(let {a = (head st), tl = (tail st)
    , b = (head tl), st' = (tail tl)}
    (cons b (cons a st')))
</pre>
<p>let expression introduces variables (a, tl, b, st')
and evaluates the body expression <tt class="docutils literal">(cons b (cons a <span class="pre">st'))</span></tt>
that contains those variables introduced.</p>
<p>cons takes an element and a list and puts the element
to the front of the list:</p>
<pre class="literal-block">
LIPL&gt; (cons 1 [2,3])
type: [Int]
[1, 2, 3]
LIPL&gt; (cons 1 ['b'])
types do not unify
</pre>
<p>One can't cons 1 (an integer) to a list of characters because
list has to be homogeneous (elements have all same type).</p>
<p>So, swapOp takes 2 elements from the list
and cons the front element first then the 2nd element
(essentially swapping them):</p>
<pre class="literal-block">
(swapOp &quot;abc&quot;)
==&gt; &quot;bac&quot;
(swapOp [1,2])
==&gt; [2,1]
</pre>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">dupOp</span> <span class="p">(</span><span class="nf">st</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">isEmpty</span> <span class="nv">st</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">println</span> <span class="s">&quot;no element to dup&quot;</span><span class="p">)</span> <span class="err">[]</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">head</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">st</span><span class="p">)))</span>
</pre></div>

</div>
<p>dupOp also takes a list and checks if it is empty.
If the list is empty, it prints a message and returns an empty list.
Otherwise, it conses head of the list (essentially duplicating the head):</p>
<pre class="literal-block">
(dupOp &quot;abc&quot;)
==&gt; &quot;aabc&quot;
</pre>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">popOp</span> <span class="p">(</span><span class="nf">st</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">isEmpty</span> <span class="nv">st</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">println</span> <span class="s">&quot;no element to pop&quot;</span><span class="p">)</span> <span class="err">[]</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">tail</span> <span class="nv">st</span><span class="p">)))</span>
</pre></div>

</div>
<p>popOp returns tail of the list when the list is not empty (essentially
popping head of the list):</p>
<pre class="literal-block">
(popOp &quot;abc&quot;)
==&gt; &quot;bc&quot;
</pre>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">arithOp</span> <span class="p">(</span><span class="nf">op</span> <span class="nv">st</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">st</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">println</span> <span class="s">&quot;don&#39;t have 2 elements for arithmetic&quot;</span><span class="p">)</span> <span class="nv">st</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="err">{</span><span class="nv">tl</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">tail</span> <span class="nv">st</span><span class="p">)</span><span class="o">,</span> <span class="nv">st</span><span class="o">&#39;</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">tail</span> <span class="nv">tl</span><span class="p">)</span>
            <span class="o">,</span> <span class="nv">arg1</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">head</span> <span class="nv">tl</span><span class="p">)</span><span class="o">,</span> <span class="nv">arg2</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">head</span> <span class="nv">st</span><span class="p">)</span><span class="err">}</span>
            <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">op</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">)</span> <span class="nv">st</span><span class="o">&#39;</span><span class="p">))))</span>
</pre></div>

</div>
<p>arithOp takes a binary arithmetic function (op)
and a list.
It first checks if the list has at least 2 elements.
Then it pops the 2 elements and calls them arg2 and arg1
(head of the list is called arg2 and the 2nd element is called arg1).
And it applies the binary function to arg1 and arg2
and conses the result to the list with arg1 and arg2 popped:</p>
<pre class="literal-block">
(arithOp + [1,2])
==&gt; [3]
(arithOp - [1,2,10])
==&gt; [-1, 10]
</pre>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">clearOp</span> <span class="p">(</span><span class="nf">st</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">isEmpty</span> <span class="nv">st</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">println</span> <span class="s">&quot;nothing to clear&quot;</span><span class="p">)</span> <span class="err">[]</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">printStack</span> <span class="nv">st</span><span class="p">)</span> <span class="err">[]</span><span class="p">)))</span>
</pre></div>

</div>
<p>clearOp prints content of the list and returns an empty list
if the list is not empty. If the list is empty, a message is printed
and an empty list is returned.</p>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">isInt</span> <span class="p">(</span><span class="nf">s</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">isEmpty</span> <span class="nv">s</span><span class="p">)</span>
        <span class="nv">False</span>
        <span class="p">(</span><span class="nf">all</span> <span class="nv">isNum</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="ss">&#39;-</span><span class="o">&#39;</span> <span class="p">(</span><span class="nf">head</span> <span class="nv">s</span><span class="p">))</span> <span class="p">(</span><span class="nf">tail</span> <span class="nv">s</span><span class="p">)</span> <span class="nv">s</span><span class="p">))))</span>
</pre></div>

</div>
<p>isInt checks if a string is made of all numeric characters
('0', '1', '2', ..., '9') with optional leading <tt class="docutils literal">-</tt>.
isNum checks if a character is numeric.
all takes a function and a list and checks if all elements in the
list satisfies the given function:</p>
<pre class="literal-block">
(all (lambda (x) (&lt; x 2)) [0, 1, 2])
==&gt; False because of the last element, 2.
(all isNum &quot;00002342&quot;)
==&gt; True
(all isNum &quot;-030424&quot;)
==&gt; True
(all isNum &quot;-0a&quot;)
==&gt; False
</pre>
</div>
<div class="section" id="evaluator">
<h1><a class="toc-backref" href="#id4">4&nbsp;&nbsp;&nbsp;Evaluator</a></h1>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">eval</span> <span class="p">(</span><span class="nf">st</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">isEmpty</span> <span class="nv">l</span><span class="p">)</span>
    <span class="nv">st</span>
    <span class="p">(</span><span class="k">let </span><span class="err">{</span><span class="nv">x</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">head</span> <span class="nv">l</span><span class="p">)</span><span class="o">,</span> <span class="nv">xs</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">tail</span> <span class="nv">l</span><span class="p">)</span><span class="err">}</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;-&quot;</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">arithOp</span> <span class="nv">-</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;+&quot;</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">arithOp</span> <span class="nv">+</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;*&quot;</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">arithOp</span> <span class="nv">*</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;/&quot;</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">arithOp</span> <span class="nv">div</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;swap&quot;</span> <span class="nv">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">swapOp</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;dup&quot;</span> <span class="nv">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">dupOp</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;pop&quot;</span> <span class="nv">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">popOp</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;.&quot;</span> <span class="nv">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nf">clearOp</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">isInt</span> <span class="nv">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">readInt</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">st</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nf">concat</span> <span class="s">&quot;not integer: &quot;</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">st</span><span class="p">)))))))))))))</span>
</pre></div>

</div>
<p>eval takes 2 lists (st and l).
When l is empty, it returns st.
st is stack (or list) of integers. l is a list of inputs (stack commands).
When the first input (head l) is arithmetic operator,
arithOp is called accordingly.
If it is swap, dup, pop, or ., appropriate function is called
that swaps, duplicates, pops, or clears the stack.
Since all helper functions take a stack (list) and returns
a stack, result of the helper function (a stack)
is passed to recursive eval function on the remaining argument (xs).
eval function itself returns the stack when input is all consumed.</p>
</div>
<div class="section" id="repl">
<h1><a class="toc-backref" href="#id5">5&nbsp;&nbsp;&nbsp;REPL</a></h1>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">prompt</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">getLine</span><span class="p">))</span>
</pre></div>

</div>
<p>prompt takes a string and prints it. Then it gets user input.</p>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">repl</span> <span class="p">(</span><span class="nf">st</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="err">{</span> <span class="nv">input</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">prompt</span> <span class="s">&quot;CALC&gt; &quot;</span><span class="p">)</span> <span class="err">}</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;:q&quot;</span> <span class="nv">input</span><span class="p">)</span>
            <span class="p">()</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">==</span> <span class="s">&quot;:s&quot;</span> <span class="nv">input</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">seq</span> <span class="p">(</span><span class="nf">printStack</span> <span class="nv">st</span><span class="p">)</span> <span class="p">(</span><span class="nf">repl</span> <span class="nv">st</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">repl</span> <span class="p">(</span><span class="nb">eval </span><span class="nv">st</span> <span class="p">(</span><span class="nf">parse</span> <span class="nv">input</span><span class="p">)))))))</span>
</pre></div>

</div>
<p>repl gets user input from the prompt, &quot;CALC&gt; &quot;.
When the input is &quot;:q&quot;, it returns null value.
If the input is &quot;:s&quot;, it prints stack content and recurses
(prompt is shown again waiting for user input).
Otherwise, it calls eval function after parsing user input.
repl takes a stack of integers and feed it to eval function, which
returns modified stack, which can be used in repl again for recursion:</p>
<pre class="literal-block">
st --&gt; repl --&gt; st --&gt; eval -+
^                            |
|                            |
+----------------------------+
</pre>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">msg</span> <span class="p">()</span>
    <span class="s">&quot;</span>
<span class="s">Welcome to Stack Based Postfix Calculator</span>
<span class="s">- :q        quits</span>
<span class="s">- :s        shows stack content</span>
<span class="s">- .         clears stack</span>
<span class="s">- swap      swaps top 2 elements from the stack</span>
<span class="s">- dup       duplicates top element from the stack</span>
<span class="s">- pop       pops top element from the stack</span>
<span class="s">- only calculates postfix arithmetic expressions</span>
<span class="s">  involving Integers, +, -, *, /&quot;</span><span class="p">)</span>
</pre></div>

</div>
<p>msg is just a string literal that is shown when the calculator starts.</p>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">def</span> <span class="nv">main</span> <span class="p">()</span>
    <span class="p">(</span><span class="nf">seq</span>
        <span class="p">(</span><span class="nf">println</span> <span class="nv">msg</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">repl</span> <span class="err">[]</span><span class="p">)))</span>
</pre></div>

</div>
<p>main function prints msg (welcome message) and
starts repl on empty stack. repl will not quit until user enters &quot;:q&quot;.</p>
<div class="syntax scheme">
<div class="highlight"><pre><span class="p">(</span><span class="nf">main</span><span class="p">)</span>
</pre></div>

</div>
<p>Lastly, main function itself is called.</p>
</div>
<div class="section" id="run">
<h1><a class="toc-backref" href="#id6">6&nbsp;&nbsp;&nbsp;Run</a></h1>
<p>With all functions defined and main function called at the bottom
of calc.lipl file, we can run calc.lipl through LIPL interpreter:</p>
<pre class="literal-block">
shell&gt; lipl calc.lipl
core.lipl loaded

Welcome to Stack Based Postfix Calculator
...
CALC&gt; 1 2
CALC&gt; :s
2
1
CALC&gt; swap .
1
2
CALC&gt; :s
CALC&gt; 2 dup * dup * dup * .
256
CALC&gt; :q
shell&gt;
</pre>
</div>
</div>

</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2157648-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>
