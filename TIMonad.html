<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>TIMonad.lhs -- LIPL</title>
    <link href="style.css" rel="stylesheet" type="text/css" media="screen"/>
    <link href="print.css" rel="stylesheet" type="text/css" media="print"/>
</head>
<body>
<div id="wrap">
<div class="document" id="timonad-lhs">
<h1 class="title">TIMonad.lhs</h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#more-about-monads" id="id1">1&nbsp;&nbsp;&nbsp;More About Monads</a></li>
<li><a class="reference internal" href="#monad-transformers" id="id2">2&nbsp;&nbsp;&nbsp;Monad Transformers</a></li>
</ul>
</div>
<p>TIMonad module implements MonadTI class and provides TI monad
and TIT monad transformer.
TI stands for Type Inference.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="cm">{-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies</span>
<span class="cs">&gt;     </span><span class="cm">, FlexibleInstances, GeneralizedNewtypeDeriving #-}</span>
<span class="cs">&gt; </span><span class="cm">{-# OPTIONS_GHC -fallow-undecidable-instances #-}</span>
</pre></div>

</div>
<p>Above pragmas and option are needed.
Their meanings can be found in:
<a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html">http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html</a></p>
<p>LANGUAGE pragma enables language extensions that are not part of haskell98
standard.
GHC suggests extensions to enable when it can't compile a module.
So, one can include proper pragmas by trial and error.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">module</span> <span class="nn">TIMonad</span> <span class="p">(</span>
<span class="cs">&gt;     </span><span class="nf">module</span> <span class="kt">TIMonadClass</span>
<span class="cs">&gt;     </span><span class="p">,</span> <span class="nf">module</span> <span class="kt">TIMonad</span>
<span class="cs">&gt; </span><span class="p">)</span> <span class="kr">where</span>
</pre></div>

</div>
<p>TIMonad exports TIMonadClass module and TIMonad module (itself).
So, upon importing TIMonad, one can access MonadTI (defined in TIMonadClass)
and all top level functions defined in this module (TIMonad).</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.List</span> <span class="k">as</span> <span class="n">List</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Control.Monad.Error</span> <span class="k">as</span> <span class="n">E</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Control.Monad.State</span> <span class="k">as</span> <span class="n">S</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Control.Monad.Reader</span> <span class="k">as</span> <span class="n">R</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Control.Monad.Writer</span> <span class="k">as</span> <span class="n">W</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Control.Monad.Trans</span> <span class="k">as</span> <span class="n">T</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Control.Monad.Fix</span> <span class="k">as</span> <span class="n">F</span>
<span class="cs">&gt;</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="nn">EvalMonadClass</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="nn">TIMonadClass</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="nn">Type</span>
<span class="cs">&gt; </span><span class="kr">import</span> <span class="nn">PosMonadClass</span>
</pre></div>

</div>
<div class="section" id="more-about-monads">
<h1><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;More About Monads</a></h1>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">newtype</span> <span class="kt">TI</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">{</span> <span class="n">runTI</span> <span class="ow">::</span> <span class="kt">Subst</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Subst</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="p">}</span>
</pre></div>

</div>
<p>Unlike type synonym, newtype defines a brand new type.
For example, after defining type synonym <tt class="docutils literal">type MyInt = Int</tt>,
MyInt can be used where Int can be used.
However, after <tt class="docutils literal">newtype MyInt = MyInt Int</tt>, MyInt is a different type.
So, newtype is similar to data declaration. But, only 1 data
constructor containing a single field is allowed.</p>
<p>TI is a type constructor that takes a type and returns another type.
TI is also a data constructor that takes
a function of type <tt class="docutils literal">Subst <span class="pre">-&gt;</span> Int <span class="pre">-&gt;</span> (Subst, Int, a)</tt>
(takes a Subst and an Int and returns a tuple of a Subst, an Int
and a value of type a)
and returns a value of type TI a.
The type variable a in <tt class="docutils literal">TI a</tt> will be determined by the
function passed in to TI data constructor.
For example:</p>
<pre class="literal-block">
TI (\s i -&gt; (s, i, 1)) :: TI Int
TI (\s i -&gt; (s, i, &quot;hello&quot;)) :: TI String
</pre>
<p>So, a value of type TI stores a function.
State type defined in mtl (monad transformer library)
also stores a function:</p>
<pre class="literal-block">
newtype State s a = State {
    runState :: (s -&gt; (a, s))
}
</pre>
<p>TIMonad, which is very similar to State, is just a custom State monad.
One would just use State monad from mtl library:
<a class="reference external" href="http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html">http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html</a>
However, a custom monad is created for exercise.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">TI</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">runTI</span> <span class="n">f</span> <span class="n">s</span> <span class="n">n</span>
<span class="cs">&gt;         </span><span class="kr">in</span>
<span class="cs">&gt;             </span><span class="nf">runTI</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="n">s&#39;</span> <span class="n">n&#39;</span><span class="p">)</span>
</pre></div>

</div>
<p>This mimics how State monad is implemented.
For TI to be a Monad, it implements 2 functions from Monad class
(other functions from Monad class have default implementation
that works properly given these 2 functions):
return and <tt class="docutils literal">&gt;&gt;=</tt>.</p>
<p>return function returns a value of type TI whose function
(TI stores a function)
puts the argument, x, on the 3rd place of the tuple.</p>
<p><tt class="docutils literal">&gt;&gt;=</tt> returns a value of type TI whose function
takes s and n (Subst and Int) and calls runTI on
f (of type TI a), s, and n.
runTI has type <tt class="docutils literal">TI a <span class="pre">-&gt;</span> Subst <span class="pre">-&gt;</span> Int <span class="pre">-&gt;</span> (Subst, Int, a)</tt>.
So, runTI f s n returns a value of type (Subst, Int, a).
(s', n', x) is the return value of runTI.
Then, it calls runTI again on g x, s', and n'.</p>
<pre class="literal-block">
ghci&gt; :t (&gt;&gt;=)
(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<p><tt class="docutils literal">:t</tt> is GHCi command that prints type of the given expression.
So, f in <tt class="docutils literal">f &gt;&gt;= g</tt> has type TI a.
And, g has type <tt class="docutils literal">a <span class="pre">-&gt;</span> TI b</tt>.
So, <tt class="docutils literal">runTI (g x) s' n'</tt> returns (Subst, Int, b) because (g x)
has type TI b.</p>
<p>All this can be summarized as:</p>
<pre class="literal-block">
TI (\s n -&gt; (a, b, c))
     | |     |  |  +--- value to be returned in TI monad.
     | |     |  +------ Int value passed to next TI action.
     | |     +--------- Subst value passed to next TI action.
     | +--------------- Int value from previous TI action.
     +----------------- Subst value from previous TI action.
</pre>
<p>Start GHCi and try these:</p>
<pre class="literal-block">
ghci&gt; :l TIMonad
ghci&gt; runTI (return 1) nullSubst 0
(fromList [],0,1)
ghci&gt; runTI (return &quot;hello&quot;) nullSubst 0
(fromList [],0,&quot;hello&quot;)
</pre>
<p>Just as return function is implemented, return whatever
puts whatever on the 3rd position of the tuple.</p>
<pre class="literal-block">
ghci&gt; let action = return 1 &gt;&gt;= (\x -&gt; return (x + 1)) :: TI Int
ghci&gt; runTI action nullSubst 100
(fromList [],100,2)
</pre>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="kt">MonadTI</span> <span class="kt">TI</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">getSubst</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">putSubst</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">()</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">extendSubst</span> <span class="n">s&#39;</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="o">@@</span> <span class="n">s&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">()</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">newId</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">succ</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;t&quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">getN</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">putN</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">()</span><span class="p">))</span>
</pre></div>

</div>
<p>TI being a Monad, it can now be an instance of MonadTI.</p>
<ul class="simple">
<li>getSubst just returns current s (Subst) by putting it at the 3rd place
of the tuple.</li>
<li>putSubst ignores current Subst being passed to (_). And passes s
on to the next TI action (by putting s on 1st place of the tuple).</li>
<li>extendSubst takes a Subst (s') and
modifies s passed from the previous TI action
and passes out the modified Subst (<tt class="docutils literal">s &#64;&#64; s'</tt>).</li>
<li>newId returns &quot;tN&quot; where N is Int came from the previous TI action.
And it passes successor of n to the next TI action.
The next TI action will get a brand new Int (successor of
the previous Int).</li>
<li>getN returns n passed from the previous TI action.</li>
<li>putN passes n onto the next TI action.</li>
</ul>
<p>So, TI monad threads (gets values from previous TI action and passes
out values to the next TI action) Subst and Int values, while
returning a value of arbitrary type.
This gives illusion of having global Subst and Int,
in addition to a value of arbitrary type, inside TI monad.</p>
<p>It might be tedious to combine actions like:</p>
<pre class="literal-block">
action1 &gt;&gt;= (\x -&gt; action2) &gt;&gt;= (\y -&gt; action3)
</pre>
<p>So, one could use do notation instead:</p>
<pre class="literal-block">
do
    x &lt;- action1
    y &lt;- action2
    action3

or

do { x &lt;- action1; y &lt;- action2;
    action3 }
</pre>
<p><tt class="docutils literal">&gt;&gt;=</tt>, monadic bind, is similar to function composition <tt class="docutils literal">.</tt>:</p>
<pre class="literal-block">
f . g
==&gt; apply g. get return value. call it x.
==&gt; apply f to x.

f &gt;&gt;= (\x -&gt; g)
==&gt; compute f. get return value.
==&gt; feed the return value to (\x -&gt; g).
==&gt; compute g in the environment where the return value
    of f is bound to x.
</pre>
<p>Function composition (f . g) is:</p>
<pre class="literal-block">
      +---+
b --&gt; | f | --&gt; c
      +---+

.

      +---+
a --&gt; | g | --&gt; b
      +---+

==&gt;

      +---------------+
a --&gt; | g --&gt; b --&gt; f |  --&gt; c
      +---------------+
</pre>
<p>where f has type (b -&gt; c) and g has type (a -&gt; b).</p>
<p>Monadic bind (f &gt;&gt;= g) is:</p>
<pre class="literal-block">
      +------------------+
      | f uses input.    |
a --&gt; | computes output. |
      | puts it inside   |
      | monad.       +---+
      |              | b |
      +--------------+---+

&gt;&gt;=

      +------------------+
      | g uses input.    |
b --&gt; | computes output. |
      | puts it inside   |
      | monad.       +---+
      |              | c |
      +--------------+---+

==&gt;

      +-----------------------------------------+
      | f uses input.          g uses input.    |
a --&gt; | computes output.   +-&gt; computes output. |
      | puts it inside     |   puts it inside   |
      | monad.             |   monad.       +---+
      |                b --+                | c |
      +-------------------------------------+---+
</pre>
<p>Just like concatenative languages (like Joy) uses
juxtaposition (concatenation) for composition,
Haskell's do notation lets users concatenate aligned monadic
actions to form a monadic bind:</p>
<pre class="literal-block">
const negate
==&gt; composing two functions: negate and const.
    (const is pop in Joy).
    In Haskell, (negate . const).

do
    a &lt;- action1
    b &lt;- action2
    action3
==&gt; binding action1, action2, and action3.
</pre>
<p>TI monad, which is a custom State monad, binds TI actions
(that are composition/binding of getSubst, putSubst, getN,...etc)
in a way that Subst and Int are threaded to give illusion of
having global Subst and Int.
Other monads can implement return function and <tt class="docutils literal">&gt;&gt;=</tt>
in a way that the monads have some other features.</p>
<p>Another way of binding monadic actions is to use <tt class="docutils literal">&gt;&gt;</tt> function:</p>
<pre class="literal-block">
action1 &gt;&gt; action2
</pre>
<p><tt class="docutils literal">&gt;&gt;</tt>, unlike <tt class="docutils literal">&gt;&gt;=</tt>, discards return value of action1
(while <tt class="docutils literal">&gt;&gt;=</tt> passes the return value onto the function
that takes it and computes action2):</p>
<pre class="literal-block">
ghci&gt; :t (&gt;&gt;)
(&gt;&gt;) :: (Monad m) =&gt; m a -&gt; m b -&gt; m b
ghci&gt; :t (&gt;&gt;=)
(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<p>Using <tt class="docutils literal">&lt;-</tt> in do notation would transforms concatenation
of aligned actions
into <tt class="docutils literal">&gt;&gt;=</tt> while other concatenations would be transformed
into <tt class="docutils literal">&gt;&gt;</tt>:</p>
<pre class="literal-block">
do
    x &lt;- action1
    action2
==&gt; action1 &gt;&gt;= (\x -&gt; action2)

do
    action1
    action2
==&gt; action1 &gt;&gt; action2
</pre>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">TI</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">TI</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">let</span>
<span class="cs">&gt;         </span><span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span><span class="n">n&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">runTI</span> <span class="n">m</span> <span class="n">s</span> <span class="n">n</span>
<span class="cs">&gt;         </span><span class="kr">in</span>
<span class="cs">&gt;             </span><span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="n">f</span> <span class="n">x</span><span class="p">))</span>
</pre></div>

</div>
<pre class="literal-block">
ghci&gt; :t fmap
fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</pre>
<p>TI can also be a Functor: f is called on the 3rd value of the tuple
(which is return value). Functor's interface, fmap, can be used
to transform a value inside a monad.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="nf">newTVar</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">MonadTI</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Type</span>
<span class="cs">&gt; </span><span class="nf">newTVar</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="cs">&gt;     </span><span class="nf">v</span> <span class="ow">&lt;-</span> <span class="n">newId</span>
<span class="cs">&gt;     </span><span class="nf">return</span> <span class="p">(</span><span class="kt">TVar</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

</div>
<p>newTVar creates a brand new type variable using newId (newId
generates &quot;t0&quot;, &quot;t1&quot;, ...).</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="nf">unify</span> <span class="n">t1</span> <span class="n">t2</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="cs">&gt;     </span><span class="nf">s</span> <span class="ow">&lt;-</span> <span class="n">getSubst</span>
<span class="cs">&gt;     </span><span class="nf">u</span> <span class="ow">&lt;-</span> <span class="n">mgu</span> <span class="p">(</span><span class="n">apply</span> <span class="n">s</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">apply</span> <span class="n">s</span> <span class="n">t2</span><span class="p">)</span>
<span class="cs">&gt;     </span><span class="nf">extendSubst</span> <span class="n">u</span>
</pre></div>

</div>
<p>unify finds mgu of the 2 types. And, extends Subst in TI monad
with the mgu.</p>
</div>
<div class="section" id="monad-transformers">
<h1><a class="toc-backref" href="#id2">2&nbsp;&nbsp;&nbsp;Monad Transformers</a></h1>
<p>Having TI monad is great.
To add more features to TI monad, one can rewrite newtype TI,
return function, and <tt class="docutils literal">&gt;&gt;=</tt>.
For example, to make TI monad to have global String,
one can start with:</p>
<pre class="literal-block">
newtype TI a = TI {
    runTI :: Subst -&gt; Int -&gt; String -&gt; (Subst, Int, String, a)
    }
</pre>
<p>This gets tedious. Also, TI is just a State monad.
There are other kinds of monads that not only threads values
among bound monadic actions but also other things: some monads
might not even thread values.</p>
<p>Using monad transformers, one can stack up different monads to build
a new monad.
For example, one can stack up TI monad on top of IO monad
to make IO actions available:</p>
<pre class="literal-block">
+---+  a new monad.
|TI |  TI monad provides getSust, newId, ...etc.
|---|  (for TI being an instance of MonadTI)
|IO |  IO monad provides putStrLn, putChar, ...etc.
+---+
</pre>
<p>Actually, TIT IO is the new monad (shown above)
that supports IO actions and TI actions.
Above diagram is misleading because there is no TI monad
at the top of the stack. It is because TIT m is also an instance
of MonadTI (that provides getSubst, newId, ...) for all
m such that m is an instance of Monad class (that provides
return, <tt class="docutils literal">&gt;&gt;=</tt>, ...) that TIT IO both supports all IO actions
and actions declared in MonadTI class.</p>
<p>In mtl (monad transformer library), following convention is used:</p>
<ul class="simple">
<li>Foo.Class module defines MonadFoo class, which is used as
interface of Foo monad (MonadTI in TIMonadClass module).</li>
<li>Foo module defines type Foo and makes Foo instance of Monad.
Also, type FooT (Foo monad transformer) is defined.
FooT is made instance of many things so that it can be used
along with other monad transformers.</li>
</ul>
<p>Similar to mtl, type TIT is defined and made into TI monad transformer.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">newtype</span> <span class="kt">TIT</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">{</span> <span class="n">runTIT</span> <span class="ow">::</span> <span class="kt">Subst</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Subst</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="p">}</span>
</pre></div>

</div>
<p>TI was a type constructor that took a type a and returned
a type <tt class="docutils literal">TI a</tt>.
TIT is a type constructor that takes a type m and a and returns
a type TIT m a.
So, to construct a TIT type, one would need 2 types
(while one needs only 1 type to construct TI):</p>
<pre class="literal-block">
ghci&gt; :k TI
* -&gt; *
ghci&gt; :k TIT
(* -&gt; *) -&gt; * -&gt; *
</pre>
<p><tt class="docutils literal">:k</tt> is a GHCi command that prints kind information of
given expression.
Kind is type of types:</p>
<ul class="simple">
<li>1 has type Int</li>
<li>&quot;hello&quot; has type String</li>
<li>Int has type (kind) <tt class="docutils literal">*</tt></li>
<li>String has kind <tt class="docutils literal">*</tt></li>
<li>TI has kind <tt class="docutils literal">* <span class="pre">-&gt;</span> *</tt> (takes a type and returns a type).</li>
<li>TIT has kind <tt class="docutils literal">(* <span class="pre">-&gt;</span> *) <span class="pre">-&gt;</span> * <span class="pre">-&gt;</span> *</tt>
(takes a type constructor that takes a type and returns a type,
and a type. Then, returns a type).</li>
</ul>
<p>Since TI has kind <tt class="docutils literal">* <span class="pre">-&gt;</span> *</tt>, <tt class="docutils literal">TIT TI Int</tt> would be a valid type.
However, <tt class="docutils literal">TIT String Int</tt> won't be a valid type because
String has kind <tt class="docutils literal">*</tt>, not <tt class="docutils literal">* <span class="pre">-&gt;</span> *</tt>, which TIT expects.</p>
<p>Kind of TIT, <tt class="docutils literal">(* <span class="pre">-&gt;</span> *) <span class="pre">-&gt;</span> * <span class="pre">-&gt;</span> *</tt> can be written as
<tt class="docutils literal">(* <span class="pre">-&gt;</span> *) <span class="pre">-&gt;</span> (* <span class="pre">-&gt;</span> *)</tt>: takes a type constructor with arity 1
and returns a type constructor with arity 1 (with currying
every function has arity 1. But here, arity 1 is used
to refer to types of kind <tt class="docutils literal">* <span class="pre">-&gt;</span> *</tt>).
So, one can imagine TIT taking a monad (can be a type
constructor of kind <tt class="docutils literal">* <span class="pre">-&gt;</span> *</tt>, just like State String)
and a type (like Int),
and transforming the monad into another monad by adding
MonadTI actions on top of it (TIT m is also an instance of MonadTI):</p>
<pre class="literal-block">
ghci&gt; :m + Control.Monad.State
ghci&gt; :l TIMonad
ghci&gt; :k State String
State String :: * -&gt; *
ghci&gt; :k TIT (State String) Int
TIT (State String) Int :: *
ghci&gt; :k TIT (State String)
* -&gt; *
ghci&gt; :k TI
* -&gt; *
</pre>
<p><tt class="docutils literal">:m + ModuleName</tt> makes exported names of ModuleName
available to GHCi (importing/appending ModuleName).</p>
<p>So, <tt class="docutils literal">TIT (State String)</tt> is a monad that looks like:</p>
<pre class="literal-block">
+--------------+ a new monad.
| TIT          | TIT m provides putSubst, getN, ...etc
|--------------|     where m is a monad.
| State String | State String provides put and get
+--------------+ that puts a String and returns a String
                 respectively.
</pre>
<p>A <tt class="docutils literal">TIT (State String)</tt> action can return any type inside.
And it can use all actions TI and State String
provide: putSubst, getN, put, get, ...etc.</p>
<p>One can stack up more monads by using other transformers like:
StateT, ReaderT, WriterT... to build more complicated monad.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
<span class="cs">&gt;         </span><span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">runTIT</span> <span class="n">m</span> <span class="n">s</span> <span class="n">n</span>
<span class="cs">&gt;         </span><span class="nf">runTIT</span> <span class="p">(</span><span class="n">k</span> <span class="n">x</span><span class="p">)</span> <span class="n">s&#39;</span> <span class="n">n&#39;</span><span class="p">)</span>
<span class="cs">&gt;     </span><span class="nf">fail</span> <span class="n">str</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">fail</span> <span class="n">str</span><span class="p">)</span>
</pre></div>

</div>
<p>In the context where m is a Monad, TIT m is also a Monad.
Change from TI's definition of return and <tt class="docutils literal">&gt;&gt;=</tt> is that
return values of the function <tt class="docutils literal">\s n <span class="pre">-&gt;</span> ...</tt> are monads:</p>
<pre class="literal-block">
return (s, n, x) instead of (s, n, x)
runTIT instead of runTI

ghci&gt; :t runTI
runTI :: TI a -&gt; Subst -&gt; Int -&gt; (Subst, Int, a)
ghci&gt; :t runTIT
runTIT :: TIT m a -&gt; Subst -&gt; Int -&gt; m (Subst, Int, a)
</pre>
<p>runTI returns (Subst, Int, a) while runTIT returns m (Subst, Int, a):
(Subst, Int, a) inside a monad, m.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
<span class="cs">&gt;         </span><span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">runTIT</span> <span class="n">m</span> <span class="n">s</span> <span class="n">n</span>
<span class="cs">&gt;         </span><span class="nf">return</span> <span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="n">f</span> <span class="n">x</span><span class="p">))</span>
</pre></div>

</div>
<p>Similarly, the return value above is turned to a monad
(a tuple in a monad) instead of
flat a tuple.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="kt">T</span><span class="o">.</span><span class="kt">MonadTrans</span> <span class="kt">TIT</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">lift</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
<span class="cs">&gt;         </span><span class="nf">a</span> <span class="ow">&lt;-</span> <span class="n">m</span>
<span class="cs">&gt;         </span><span class="nf">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
</pre></div>

</div>
<p>MonadTrans class' lift function turns a monadic action
into a different monadic action:</p>
<pre class="literal-block">
ghci&gt; :t lift
lift :: (Monad m, MonadTrans t) =&gt; m a -&gt; t m a
</pre>
<p>Let there be a monad M that is built with M1T m
to stack up M1 on top of existing monad (stack):</p>
<pre class="literal-block">
this is monad M
+----+
| M1T| M1T m supports m1Action
|----|     where m is any monad.
| .. | existing monad stack
+----+
</pre>
<p>Let there be monad M2 that is inside the existing monad stack
above:</p>
<pre class="literal-block">
+----+
| M2 | M2 supports m2Action
+----+
</pre>
<p>In M, one can't call m2Action although M2 might be part of M:</p>
<pre class="literal-block">
do           -- inside M
    m2Action -- can't be done unless m2Action is made into
             -- M action
</pre>
<p>To turn m2Action into an action that can be used in M, one can use
lift function:</p>
<pre class="literal-block">
do                -- inside M
    lift m2Action -- this is now an action lifted onto M
</pre>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadTI</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">getSubst</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">putSubst</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">()</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">extendSubst</span> <span class="n">s&#39;</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">@@</span> <span class="n">s&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">()</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">newId</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;t&quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">getN</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
<span class="cs">&gt;     </span><span class="nf">putN</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">()</span><span class="p">))</span>
</pre></div>

</div>
<p>By making TIT m an instance of MonadTI,
getSubst, putSubst,...etc can be used inside a monad
that is built up using TIT monad transformer:</p>
<pre class="literal-block">
TIT (State String)
can now use getSubst, putSubst, ...
</pre>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">T</span><span class="o">.</span><span class="kt">MonadIO</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">T</span><span class="o">.</span><span class="kt">MonadIO</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">liftIO</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="o">.</span> <span class="kt">T</span><span class="o">.</span><span class="n">liftIO</span>
</pre></div>

</div>
<p>liftIO turns an IO action into current monad action:</p>
<pre class="literal-block">
ghci&gt; :t liftIO
liftIO :: (MonadIO m) =&gt; IO a -&gt; m a
</pre>
<p>So, for TIT m, where m is an instance of MonadIO,
all IO actions are turned into m action by using liftIO first.
Then, the m action is lifted to TIT m action using lift function.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">E</span><span class="o">.</span><span class="kt">MonadError</span> <span class="n">e</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">E</span><span class="o">.</span><span class="kt">MonadError</span> <span class="n">e</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">throwError</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="o">.</span> <span class="kt">E</span><span class="o">.</span><span class="n">throwError</span>
<span class="cs">&gt;     </span><span class="nf">m</span> <span class="p">`</span><span class="n">catchError</span><span class="p">`</span> <span class="n">h</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">runTIT</span> <span class="n">m</span> <span class="n">s</span> <span class="n">n</span>
<span class="cs">&gt;         </span><span class="p">`</span><span class="kt">E</span><span class="o">.</span><span class="n">catchError</span><span class="p">`</span>
<span class="cs">&gt;         </span><span class="nf">\</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">runTIT</span> <span class="p">(</span><span class="n">h</span> <span class="n">e</span><span class="p">)</span> <span class="n">s</span> <span class="n">n</span><span class="p">)</span>
</pre></div>

</div>
<p>TIT m also supports throwError and catchError actions
by being an instance of MonadError e.</p>
<pre class="literal-block">
ghci&gt; :m + Control.Monad.Error
ghci&gt; :t throwError
throwError :: (MonadError e m) =&gt; e -&gt; m a
</pre>
<p>So, throwError takes an error of type e and returns a monad
that reflects occurrence of the error.
For TIT m, throwError is implemented so that the error ridden m a
(returned by call of throwError) is lifted to TIT m.
catchError runs m. In case of error, handler h is called.</p>
<div class="syntax lhs">
<div class="highlight"><pre><span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">R</span><span class="o">.</span><span class="kt">MonadReader</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">R</span><span class="o">.</span><span class="kt">MonadReader</span> <span class="n">r</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">ask</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="kt">R</span><span class="o">.</span><span class="n">ask</span>
<span class="cs">&gt;     </span><span class="nf">local</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">R</span><span class="o">.</span><span class="n">local</span> <span class="n">f</span> <span class="p">(</span><span class="n">runTIT</span> <span class="n">m</span> <span class="n">s</span> <span class="n">n</span><span class="p">)))</span>
<span class="cs">&gt;</span>
<span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">S</span><span class="o">.</span><span class="kt">MonadState</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">S</span><span class="o">.</span><span class="kt">MonadState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">get</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="kt">S</span><span class="o">.</span><span class="n">get</span>
<span class="cs">&gt;     </span><span class="nf">put</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="o">.</span> <span class="kt">S</span><span class="o">.</span><span class="n">put</span>
<span class="cs">&gt;</span>
<span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">W</span><span class="o">.</span><span class="kt">MonadWriter</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">W</span><span class="o">.</span><span class="kt">MonadWriter</span> <span class="n">w</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">tell</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="o">.</span> <span class="kt">W</span><span class="o">.</span><span class="n">tell</span>
<span class="cs">&gt;     </span><span class="nf">listen</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
<span class="cs">&gt;         </span><span class="p">((</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="kt">W</span><span class="o">.</span><span class="n">listen</span> <span class="p">(</span><span class="n">runTIT</span> <span class="n">m</span> <span class="n">s</span> <span class="n">n</span><span class="p">)</span>
<span class="cs">&gt;         </span><span class="nf">return</span> <span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">)))</span>
<span class="cs">&gt;     </span><span class="nf">pass</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">TIT</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">W</span><span class="o">.</span><span class="n">pass</span> <span class="p">(</span><span class="kr">do</span>
<span class="cs">&gt;         </span><span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span> <span class="ow">&lt;-</span> <span class="n">runTIT</span> <span class="n">m</span> <span class="n">s</span> <span class="n">n</span>
<span class="cs">&gt;         </span><span class="nf">return</span> <span class="p">((</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">n&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">)))</span>
<span class="cs">&gt;</span>
<span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadEval</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadEval</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">getEnv</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="n">getEnv</span>
<span class="cs">&gt;     </span><span class="nf">getEnvs</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="n">getEnvs</span>
<span class="cs">&gt;     </span><span class="nf">putEnvs</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="o">.</span> <span class="n">putEnvs</span>
<span class="cs">&gt;     </span><span class="nf">pushEnv</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="o">.</span> <span class="n">pushEnv</span>
<span class="cs">&gt;     </span><span class="nf">popEnv</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="n">popEnv</span>
<span class="cs">&gt;</span>
<span class="cs">&gt; </span><span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadPos</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadPos</span> <span class="p">(</span><span class="kt">TIT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
<span class="cs">&gt;     </span><span class="nf">setSourcePos</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="o">.</span> <span class="n">setSourcePos</span>
<span class="cs">&gt;     </span><span class="nf">getSourcePos</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">lift</span> <span class="n">getSourcePos</span>
</pre></div>

</div>
<p>Similarly, different classes are implemented for TIT m so that
various actions can be used inside TIT m without explicit lift.</p>
<p>MonadEval and MonadPos are to be defined in EvalMonadClass
and PosMonadClass modules respectively.</p>
</div>
</div>

</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2157648-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>
