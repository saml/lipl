# Prelude

(def map (f l) (if (isEmpty l)
                   l
                   (let {xMap = (head l), xsMap = (tail l)}
                        (cons (f xMap) (map f xsMap)))))

(def concat (l1 l2) (if (isEmpty l1)
                        l2
                        (let {xcc = (head l1), xscc = (tail l1)}
                             (cons xcc (concat xscc l2)))))
(def filter (f l)
     (if (isEmpty l)
         l
         (let {
                xf  = (head l)
              , xsf = (filter f (tail l))
              }
              (if (f xf)
                  (cons xf xsf)
                  xsf))))

# simple quick sort
(def quick-sort (l) (if (isEmpty l) # is the list empty?
    l
    (let {     x       = (head l)
             , xs      = (tail l)
             , lesser  = (filter (lambda (a) (< a x))  xs)
             , greater = (filter (lambda (a) (>= a x)) xs)
         }
         (concat (concat (quick-sort lesser)
                         (cons x []))
                 (quick-sort greater)))))

# (let { x = (head l), xs = (tail l) } (filter (lambda (a) (< a x))  xs))

(def filter_ (f l)
     (if (isEmpty l)
         l
         (if (f (head l))
             (cons (head l) (filter f (tail l)))
             (filter f (tail l)))))

(def qs (l)
     (if (isEmpty l)
         l
         (concat
                (concat
                       (qs
                            (filter (lambda (a) (< a (head l))) (tail l)))
                       (cons (head l) []))
                (qs (filter (lambda (a) (>= a (head l))) (tail l))))))

(def compose (f g x) (f (g x)))

(def apply (f x) (f x))

(def id (a) a)

(def trace (msg x) (if (println msg) x x))

(def fac (n) (if (<= n 1) 1 (* n (fac (- n 1)))))

(def fib (n)
    (if (< n 2)
        n
        (let { i = (fib (- n 1)), i-1 = (fib (- n 2)) }
             (+ i i-1))))

(def twice (f x) (f (f x)))

(def succ (x) (+ x 1))

{-
((twice twice succ) 0)
==> (twice (twice succ) 0)
==> ((twice succ) ((twice succ) 0))
==> (succ (succ ((twice succ) 0)))
==> (+ (succ ((twice succ) 0)) 1)
==> (+ (+ ((twice succ) 0) 1) 1)
==> (+ (+ (succ (succ 0)) 1) 1)
==> (+ (+ (succ 1) 1) 1)
==> (+ (+ 2 1) 1)
==> (+ 3 1)
==> 4

((twice (twice (twice succ))) 0)
==> ((twice (twice (succ (succ)))) 0)
==> (twice ((succ (succ)) ((succ (succ)))) 0)
==> ((succ succ) ((succ succ) 0))
==> ((succ succ) (succ (succ 0)))
==> ((succ succ) 2)
==> (succ (succ 2))
==> 4
-}

(def hello (s) (println (concat "hello
                         world" (show s))))
