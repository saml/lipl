# Prelude

(def map (f l) (if (isEmpty l)
                   l
                   (let {x = (head l), xs = (tail l)}
                        (cons (f x) (map f xs)))))

(def concat (l1 l2) (if (isEmpty l1)
                        l2
                        (let {x = (head l1), xs = (tail l1)}
                             (cons x (concat xs l2)))))
(def filter (f l)
     (if (isEmpty l)
         l
         (let {
                x  = (head l)
              , xs = (filter f (tail l))
              }
              (if (f x)
                  (cons x xs)
                  xs))))

# simple quick sort
(def quick-sort (l) (if (isEmpty l) # is the list empty?
    l
    (let {     x       = (head l)
             , xs      = (tail l)
             , lesser  = (filter (lambda (a) (< a x))  xs)
             , greater = (filter (lambda (a) (>= a x)) xs)
         }
         (concat (concat (quick-sort lesser)
                         (cons x []))
                 (quick-sort greater)))))

(def qs (l) (if (isEmpty l)
    l
    ((concat (concat (qs
                      (filter (lambda (a) (< a (head l))) (tail l)))
                     (cons (head l) []))
             (qs
              (filter (lambda (a) (>= a (head l))) (tail l)))))))

(def compose (f g x) (f (g x)))

(def apply (f x) (f x))

(def id (a) a)

(def trace (msg x) (if (println msg) x x))

(def fac (n) (if (<= n 1) 1 (* n (fac (- n 1)))))

(def fib (n)
    (if (< n 2)
        n
        (let { i = (fib (- n 1)), i-1 = (fib (- n 2)) }
             (+ i i-1))))

