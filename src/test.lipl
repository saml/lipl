(def map (f l) (if (isEmpty l)
                   l
                   (let {x = (head l), xs = (tail l)}
                        (cons (f x) (map f xs)))))

(def concat (l1 l2) (if (isEmpty l1)
                        l2
                        (let {x = (head l1), xs = (tail l1)}
                             (cons x (concat xs l2)))))

(def filter (f l) (if (isEmpty l)
                      l
                      (let {x = (head l), xs = (filter f (tail l))}
                           (if (f x)
                               (cons x xs)
                               xs))))

(def quick-sort (l n) (if (isEmpty l)
    (trace (concat "last: " (show n)) l)
    (let {     x       = (head l)
             , xs      = (tail l)
             , lesser  = (filter (lambda (a)
                          (< a x))  xs)
             , greater = (filter (lambda (a)
                          (>= a x)) xs)
         }
         (concat (concat (quick-sort lesser (trace (show (+ n 1)) (+ n 1)))
                         (cons x []))
                 (quick-sort greater (trace (show (+ n 2)) (+ n 2)))))))

(def compose (f g x) (f (g x)))

(def apply (f x) (f x))

(def id (a) a)

(def trace (msg x) (if (println msg) x x))

(= a 42)

(def foo (a b)
    (if (== a b)
        "they are the same"
        "they are different"))


(def one (a) (let {a = 1, b = 0} (+ b a)))

(= fortyTwo
    (+ ( if ( == 1 2)
        True
        (if (== 'a' 'b')
            1
            2 ) )
     40))

(= fortyTwo2
    (+ (if (  && (== 1 1.0)
                 (head (tail ([False, (!= "hello" "world"), False]))))
        2
        -2)
     (* 10 (+ (- 1  -1  ) (/ (* 2 2) 2.0)  ))))

(def main () (println (show (quick-sort [3,2,1]))))

