
(def parseQuoted' (n acc l)
    (if (isEmpty l)
        ""
        (let {x = (head l), xs = (tail l)
            , acc' = (concat acc (concat x " ")) }
            (if (&& (== n 0) (== x "]"))
                (concat acc (unwords l))
            (if (&& (> n 0) (== x "]"))
                (parseQuoted' (- n 1) acc' xs)
            (if (== x "[")
                (parseQuoted' (+ n 1) acc' xs)
                (parseQuoted' n acc' xs)))))))


(def parseQuoted (l) # (head l) should be "["
    (concat "[ " (parseQuoted' 0 "" (tail l))))

(def peel (s)
    (let {f = (compose tail snd)
        , x = (f (break (== '[') s))
        , y = (f (break (== ']') (reverse x))) }
        (reverse y)))

{-
(def eval (env st l)
    (if (isEmpty l)

(def parse (l)
    (if (isEmpty l)
        []
        (let {x = (head l)}
            (if (== "[" x)
                (peel

(def eval (env st l)
    (let { x = (head l) }
        (if (== "." x)
            (exe env st)
        (if (== ":" x)
            (updateEn


(def parse (l)
    (if (isEmpty l)
        []
        (let {x = (head l), xs = (tail l)}
            (if (== "[" x)
                (parseQuoted 0 xs)



(def eval (st l) (if (isEmpty l)
    (if (== 1 (length st))
        (head st)
        (seq (println "not well formed") 0))
    (let {x = (head l), xs = (tail l)}
        (if (|| (== "-" x)
            (|| (== "+" x)
            (|| (== "*" x)
                (== "/" x))))
            (if (< (length st) 2)
                (seq (println "not well formed. to many ops") 0)
                (let {arg1 = (head (tail st)), arg2 = (head st)
                        , st' = (tail (tail st))}
                    (if (== "+" x)
                        (eval (cons (+ arg1 arg2) st') xs)
                    (if (== "-" x)
                        (eval (cons (- arg1 arg2) st') xs)
                    (if (== "*" x)
                        (eval (cons (* arg1 arg2) st') xs)
                        (eval (cons (div arg1 arg2) st') xs))))))
            (eval (cons (readInt x) st) xs)))))


(def prompt (x) (seq (print x) getLine))

(def repl ()
    (let { input = (prompt "joy> ") }
        (if (== ":q" input)
            ()
            (seq
                (println
                    (concat "==> " (show (eval [] (parse input)))))
                repl))))

(def msg ()
    "
Welcome to minimal Joy repl
:q quits
:s prints stack content")

(def main ()
    (seq
        (println msg)
        repl))

# (main)

-}
